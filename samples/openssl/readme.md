
# 对称加密
1、生成随机密钥和IV
2、加密
3、解密
作用
防止信息暴露，但是密钥传递是个麻烦事，这个时候则需要非对称加密，有些加密的同时可以生成hash，做完成性校验
典型算法
aes

# 非对称加密
1、生成密钥对 -- 存储为公钥和私钥字符串，也可以存储为公钥文件和私钥文件
2、公钥加密
3、私钥解密
作用
防止信息暴露，但是性能很差，主要是用来做密钥交换
典型算法
rsa

# 签名和验签
1、生成密钥对 -- 公钥文件和私钥文件，也可以存储为字符串
2、私钥签名
3、公钥验签
作用 
防篡改 -- msg的hash值不变
放抵赖 -- 只有你的公钥才能验证你用私钥签名的消息，但是没有锲约精神，还是并不能说明这个公钥是它的，所以引入身份证书，第3方机构做裁判
签名 + 验签本身可实现 “防篡改” 和 “理论上的防抵赖”，但依赖于 “公钥确实属于发送方” 这一前提。
数字证书通过第三方 CA 的背书，解决了 “公钥与身份绑定” 的信任问题，让 “防抵赖” 在实际场景中可落地。

简言之：签名解决 “消息完整性和来源可证明性”，证书解决 “公钥的身份归属”，二者结合形成完整的信任链。
典型算法
rsa

# 身份证书
1、根证书生成：生成密钥对，私钥存好，利用公钥自签名生成根证书，证书携带公钥
2、用户证书生成：生成密钥对，私钥存好，利用公钥以及ca证书生成用户证书，证书携带用户信息以及公钥
3、签名：利用用户私钥签名传递数据
4、数据发送：原始数据+签名+用户证书
5、验签：先用根证书验证用户证书，提取用户证书中的公钥，用公钥再验证

# https模拟
运行
1、cert/gen_cert.sh生成证书
2、https_cm server
3、https_cm client
原理
所有开源库的 HTTPS 实现，本质都是先通过原始 socket 建立 TCP 连接，再在其上叠加 SSL/TLS 安全层
客户端大概代码
// 伪代码：在TCP之上上建立SSL连接
SSL_CTX* ctx = SSL_CTX_new(TLS_client_method()); // 初始化上下文
SSL* ssl = SSL_new(ctx);                        // 创建SSL对象
SSL_set_fd(ssl, sockfd);                        // 绑定TCP套接字
SSL_connect(ssl);                               // 完成SSL握手